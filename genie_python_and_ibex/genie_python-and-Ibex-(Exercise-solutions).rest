Exercise 1
==========

From [[Getting Started|genie_python-and-Ibex-(Getting-started)]].

-   Opening a scripting window should be straightforward if Ibex is installed correctly. Once you've opened the scripting perspective, check for the following

    - Ideally the instrument will appear as ``SETUP``
    - The output when the scripting window opens should look a bit like this:

.. image:: genie_python_and_ibex/StandardStartupOutputOnDemo.png

-   To print the message, enter something like ``print "Hello, World!`` and press return

-   The square of the integers between 1 and 10 can be output with the code below. A **blank line** will indicate to the scripting window that you've finished writing the loop and it can go ahead and be executed.::

        for i in range(1,11):
            print i*i

Exercise 2
==========

From [[Common commands|genie_python-and-Ibex-(Common-commands)]]

- Use either ``g.change_title("Exercise 2")`` or ``g.change(title="Exercise 2")`` to change the title
- The following code will start the run, wait, and then pause::

    g.begin()
    g.waitfor(uamps=1, max_wait=10)
    g.pause()

- This code sets the value, run control, and limits on "MY_BLOCK". Your code may look slightly different depending how you've chosen to pass in the arguments::

    g.cset("MY_BLOCK", 5, lowlimit=1, highlimit=10, runcontrol=True)

- The following resumes the run::

    g.resume()

- This code will set the block value and check the subsequent state::

    # Can use either way of specifying cset for a single block
    g.cset(MY_BLOCK=20)

    # Can verify in any sensible way, so long as we're getting g.runstate()
    if g.runstate()=="WAITING":
        print "The instrument is waiting"
    else:
        print "The instrument is not waiting"

- The following code will scan the block from its original value down to 4. It assumes the initial value is greater than 4::

    for i in range(g.cget("MY_BLOCK")['value'], 4, -1):
        g.cset(MY_BLOCK=i)
        g.waitfor(seconds=1)
        
- This function will end the run::

     g.end()

Exercise 3
==========

From [[Scripting|genie_python-and-Ibex-(Scripting)]].

-  *Create two empty scripts:*

   - *An instrument script called ``set_up_instrument.py``*
   - *A user script called ``run_my_experiment.py``*
   - **PUT IMAGES OF THE TWO FOLDERS HERE**

-   *Update your instrument script, ``set_up_instrument.py``, so that it contains a single function*

    - *The function should be called "set_up_instrument"*
    - *It should set the title to "My experiment"*
    - *It should set the username to your name*::

        def set_up_instrument():
            g.change(title="My experiment", user="Adrian")

-   *Update your user script, ``run_my_experiment.py`` which contains a function that does the following*

    - *Begins the run*
    - *Prints the current uamps for the current period over 10 seconds at 1 second intervals*
    - *Ends the run*::

        def get_uamps_run():
            g.begin()
            # Assume this doesn't change
            period = g.get_period()
            for i in range(10):
                print "Total current after {0}s: {1}.format(i+1, g.get_uamps(period))
            g.end()

-   *Load your user script ``run_my_experiment.py``*

    - Run something like this in the scripting perspective: ``g.load_script("C:\scripts\run_my_experiment.py")``

-   *Run the instrument method you wrote in exercise 3b*

    - Run something like this in the scripting perspective: ``inst.set_up_instrument()``

-   *Run the user script method you wrote in exercise 3b*

    - Run something like this in the scripting perspective: ``get_uamps_run()`` 

Exercise 4
==========

From [[Scripting|genie_python-and-Ibex-(Scripting)]].

-   *Create a new instrument script containing a function*

    - You should create a Python file in "C:\Instrument\Settings\config\[Machine name]\Python\inst"

    - *The function sets the title to "Ramping [block name] from [initial value] to [final value]"*
    - *The method begins a run and then changes the value of the block incrementally in steps of size 1*
    - *Once the target is reached, the method ends the run*::

        def ramp(block, target):
            try:
                initial = g.cget(block)['value']
            except:
                print "Problem getting value for block {0}. Make sure it exists".format(block)
            else:
                g.change(title="Ramping {0} from {1} to {2}".format(block, initial, target))
                g.begin()

                current = initial
                small = 0.0001
                while abs(current-target) > small:
                    current = min(target, current + 1) if initial < final else max(target, current -1)
                    g.cset(block, current)
            finally: 
                g.end()

-   *Put a line at the top of your instrument script outside the function definition that prints the current title*::

        print g.get_title()
        def ramp(block, target):
            ...

-   *Create a new user script containing a function that runs the new instrument function on two different blocks*::

        def ramp_two_blocks():
            for block, target in [("MY_BLOCK", 10), ("MY_OTHER_BLOCK", -10)]:
                inst.ramp(block, target)

-   *Load and run your new user-script function*

    -    From a scripting perspective, assuming the file is called "ramp_blocks.py", run the following::

             g.load_script("C:\scripts\ramp_blocks.py")
             ramp_two_blocks()
      
-   *Where was the print statement at the top of your instrument script executed?*

    - You should have seen the current title printed during the initialisation of the scripting window
    - **PUT AN IMAGE HERE**

Exercise 5
==========

From [[Converting from OpenGENIE|genie_python-and-Ibex-(Converting-from-OpenGENIE)]].

- *Translate the following* ``OpenGENIE`` *script into* ``genie_python``::

     PROCEDURE Scan
         LOCAL i setpoint max min start step_size title nframes nimages multip
         
         max = 200.0
         min = 100.0
         
         setpoint = 0.0
         start = -100.0
         setpoint = start
         nframes = 10000
         nimages = 100
         
         step_size = 20.0
         
         LOOP i FROM 1 TO nimages
             
             setpoint = setpoint + step_size
             multip = As_Integer(setpoint/360)
             setpoint = setpoint - 360*multip
             PRINTN "New angle is: " + as_string(setpoint)
             
             IF (setpoint>=min) OR (setpoint<=max)           
                 
                 tempTitle="Image "+as_string(i)+", "+as_string(setpoint)+" degrees"
                 CHANGE TITLE=tempTitle  
                 
                 cset POSITION=setpoint
                 waitformove
                 PRINTN "Move complete. Counting for " + As_String(nframes) + " frames"
                 BEGIN
                     WAITFOR frames=nframes      
                 END
             ELSE    
                 PRINTIN "Not in interval " +As_String(min)+ "<=" As_String(setpoint)+ " >= " +As_String(max) 
             ENDIF       
                 
         ENDLOOP
     ENDPROCEDURE

- In ``genie_python`` this could be written as::

     def scan(start=-100, min=100, max=200, step_size=20, nframes=10000, nimages=100):
         for i in range(1, nimages):
              setpoint = (start + i*step_size) % 360
              print "New angle is: {0}".format(setpoint)

              if min <= setpoint <= max:
                  g.change_title("Image {0}: {1} degrees".format(i, setpoint)
                  g.cset(POSTITION=setpoint)
                  g.waitformove()
                  
                  print "Move complete. Counting for {0} frames".format(nframes)
                  g.begin()
                  g.waitfor(frames=nframes)
                  g.end()
              else:
                  print "Not in interval {1}<={0}<={2}".format(setpoint, min, max)"

-     *State any simplifications you've made*
      
      - We've put the key variables as defaulted input arguments. This allows for maximal flexibility. In reality, which variables we put as arguments and which we default will depend on context. It's not recommended to put everything as an argument and always provide defaults
      -    We've taken advantage of several pieces of Python syntax to simplify the logic
 
           - ``"...".format(*args)`` for constructing strings
           - Defining a range as a single condition ``a <= b <= c``
           - Taking the modulo of a number using ``%`` to avoid extra calculations
           - Removing the unused line ``setpoint = 0.0``
           - Several commands are unnecessary in Python, namely ``LOCAL``, ``ENDLOOP``, ``ENDIF``, ``ENDPROCEDURE``