Exercise 1
==========

From [[Getting Started|Ibex-and-genie_python:-Getting-started]].

-   *Open a scripting window in Ibex*

    - Should be straightforward if Ibex is correctly installed.
    - Ideally the instrument will appear as ``SETUP``
    - The output when the scripting window opens should look a bit like this:

.. image:: StandardStartupOutputOnDemo.png

-   *Output "Hello, world!" to the console*

    - Enter something like ``print "Hello, World!`` and press return

-   *Calculate and output the square of all the integers between 1 and 10*

    - This is best achieved with the following loop::

        for i in range(1,11):
            print i*i

    - A **blank line** will indicate to the scripting window that you've finished writing the loop and it can go ahead and be executed.

Exercise 2
==========

From [[Common commands|Ibex-and-genie_python:-Common-commands]]

- *Change the title of the run to "Exercise 2"*

  - Use either ``g.change_title("Exercise 2")`` or ``g.change(title="Exercise 2")``

- *Start a run and wait for 1 uamps (maximum wait 10 seconds) before pausing*::

    g.begin()
    g.waitfor(uamps=1, max_wait=10)
    g.pause()

- *Set the value of "MY_BLOCK" to 5, with a high limit of 10, a low limit of 1 and put it under run control*::

    g.cset("MY_BLOCK", 5, lowlimit=1, highlimit=10, runcontrol=True)

  - The arguments may be named or un-named. If named, the ordering may differ, but named arguments must appear after un-named arguments for Python to accept the method call

- *Resume the run*::

    g.resume()

- *Set the value of "MY_BLOCK" to 20 and confirm (using ``genie_python``) that the instrument has entered a waiting state*::

    # Can use either way of specifying cset for a single block
    g.cset(MY_BLOCK=20)

    # Can verify in any sensible way, so long as we're getting g.runstate()
    if g.runstate()=="WAITING":
        print "The instrument is waiting"
    else:
        print "The instrument is not waiting"

- *Decrease the value of "MY_BLOCK" down in steps of 1 until it reaches 5. Wait for 1 second between steps. Notice how the run state changes back to running when the block value drops below 10*::

    for i in range(g.cget("MY_BLOCK")['value'], 4, -1):
        g.cset(MY_BLOCK=i)
        g.waitfor(seconds=1)
        
- *End the run*::

     g.end()

Exercise 3
==========

From [[Scripting|Ibex-and-genie_python:-Scripting]].

-  *Create two empty scripts:*

   - *An instrument script called ``set_up_instrument.py``*
   - *A user script called ``run_my_experiment.py``*
   - **PUT IMAGES OF THE TWO FOLDERS HERE**

-   *Update your instrument script, ``set_up_instrument.py``, so that it contains a single function*

    - *The function should be called "set_up_instrument"*
    - *It should set the title to "My experiment"*
    - *It should set the username to your name*::

        def set_up_instrument():
            g.change(title="My experiment", user="Adrian")

-   *Update your user script, ``run_my_experiment.py`` which contains a function that does the following*

    - *Begins the run*
    - *Prints the current uamps for the current period over 10 seconds at 1 second intervals*
    - *Ends the run*::

        def get_uamps_run():
            g.begin()
            # Assume this doesn't change
            period = g.get_period()
            for i in range(10):
                print "Total current after {0}s: {1}.format(i+1, g.get_uamps(period))
            g.end()

-   *Load your user script ``run_my_experiment.py``*

    - Run something like this in the scripting perspective: ``g.load_script("C:\scripts\run_my_experiment.py")``

-   *Run the instrument method you wrote in exercise 3b*

    - Run something like this in the scripting perspective: ``inst.set_up_instrument()``

-   *Run the user script method you wrote in exercise 3b*

    - Run something like this in the scripting perspective: ``get_uamps_run()`` 

Exercise 4
==========

From [[Scripting|Ibex-and-genie_python:-Scripting]].

-   *Create a new instrument script containing a function*

    - You should create a Python file in "C:\Instrument\Settings\config\[Machine name]\Python\inst"

    - *The function sets the title to "Ramping [block name] from [initial value] to [final value]"*
    - *The method begins a run and then changes the value of the block incrementally in steps of size 1*
    - *Once the target is reached, the method ends the run*::

        def ramp(block, target):
            try:
                initial = g.cget(block)['value']
            except:
                print "Problem getting value for block {0}. Make sure it exists".format(block)
            else:
                g.change(title="Ramping {0} from {1} to {2}".format(block, initial, target))
                g.begin()

                current = initial
                small = 0.0001
                while abs(current-target) > small:
                    current = min(target, current + 1) if initial < final else max(target, current -1)
                    g.cset(block, current)
            finally: 
                g.end()

-   *Put a line at the top of your instrument script outside the function definition that prints the current title*::

        print g.get_title()
        def ramp(block, target):
            ...

-   *Create a new user script containing a function that runs the new instrument function on two different blocks*::

        def ramp_two_blocks():
            for block, target in [("MY_BLOCK", 10), ("MY_OTHER_BLOCK", -10)]:
                inst.ramp(block, target)

-   *Load and run your new user-script function*

    -    From a scripting perspective, assuming the file is called "ramp_blocks.py", run the following::

             g.load_script("C:\scripts\ramp_blocks.py")
             ramp_two_blocks()
      
-   *Where was the print statement at the top of your instrument script executed?*

    - You should have seen the current title printed during the initialisation of the scripting window
    - **PUT AN IMAGE HERE**

Exercise 5
==========

From [[Converting from OpenGENIE|Ibex-and-genie_python:-Converting-from-OpenGENIE]].

- *Translate the following* ``OpenGENIE`` *script into* ``genie_python``::

     PROCEDURE Scan
         LOCAL i setpoint max min start step_size title nframes nimages multip
         
         max = 200.0
         min = 100.0
         
         setpoint = 0.0
         start = -100.0
         setpoint = start
         nframes = 10000
         nimages = 100
         
         step_size = 20.0
         
         LOOP i FROM 1 TO nimages
             
             setpoint = setpoint + step_size
             multip = As_Integer(setpoint/360)
             setpoint = setpoint - 360*multip
             PRINTN "New angle is: " + as_string(setpoint)
             
             IF (setpoint>=min) OR (setpoint<=max)           
                 
                 tempTitle="Image "+as_string(i)+", "+as_string(setpoint)+" degrees"
                 CHANGE TITLE=tempTitle  
                 
                 cset POSITION=setpoint
                 waitformove
                 PRINTN "Move complete. Counting for " + As_String(nframes) + " frames"
                 BEGIN
                     WAITFOR frames=nframes      
                 END
             ELSE    
                 PRINTIN "Not in interval " +As_String(min)+ "<=" As_String(setpoint)+ " >= " +As_String(max) 
             ENDIF       
                 
         ENDLOOP
     ENDPROCEDURE

- In ``genie_python`` this could be written as::

     def scan(start=-100, min=100, max=200, step_size=20, nframes=10000, nimages=100):
         for i in range(1, nimages):
              setpoint = (start + i*step_size) % 360
              print "New angle is: {0}".format(setpoint)

              if min <= setpoint <= max:
                  g.change_title("Image {0}: {1} degrees".format(i, setpoint)
                  g.cset(POSTITION=setpoint)
                  g.waitformove()
                  
                  print "Move complete. Counting for {0} frames".format(nframes)
                  g.begin()
                  g.waitfor(frames=nframes)
                  g.end()
              else:
                  print "Not in interval {1}<={0}<={2}".format(setpoint, min, max)"

-     *State any simplifications you've made*
      
      - We've put the key variables as defaulted input arguments. This allows for maximal flexibility. In reality, which variables we put as arguments and which we default will depend on context. It's not recommended to put everything as an argument and always provide defaults
      -    We've taken advantage of several pieces of Python syntax to simplify the logic
 
           - ``"...".format(*args)`` for constructing strings
           - Defining a range as a single condition ``a <= b <= c``
           - Taking the modulo of a number using ``%`` to avoid extra calculations
           - Removing the unused line ``setpoint = 0.0``
           - Several commands are unnecessary in Python, namely ``LOCAL``, ``ENDLOOP``, ``ENDIF``, ``ENDPROCEDURE``