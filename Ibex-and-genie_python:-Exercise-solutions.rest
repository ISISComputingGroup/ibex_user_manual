Exercise 1
==========

From [[Getting Started|Ibex-and-genie_python:-Getting started]].

-   *Open a scripting window in Ibex*

    - Should be straightforward if Ibex is correctly installed.
    - Ideally the instrument will appear as ``SETUP``
    - The output when the scripting window opens should look a bit like this:

.. image:: StandardStartupOutputOnDemo.png

-   *Output "Hello, world!" to the console*

    - Enter something like ``print "Hello, World!`` and press return

-   *Calculate and output the square of all the integers between 1 and 10*

    - This is best achieved with the following loop::

        for i in range(1,11):
            print i*i

    - A **blank line** will indicate to the scripting window that you've finished writing the loop and it can go ahead and be executed.

Exercise 2
==========

From [[Common commands|Ibex-and-genie_python:-Common-commands]]

- *Change the title of the run to "Exercise 2"*

  - Use either ``g.change_title("Exercise 2")`` or ``g.change(title="Exercise 2")``

- *Start a run and wait for 1 uamps (maximum wait 10 seconds) before pausing*::

    g.begin()
    g.waitfor(uamps=1, max_wait=10)
    g.pause()

- *Set the value of "MY_BLOCK" to 5, with a high limit of 10, a low limit of 1 and put it under run control*::

    g.cset("MY_BLOCK", 5, lowlimit=1, highlimit=10, runcontrol=True)

  - The arguments may be named or un-named. If named, the ordering may differ, but named arguments must appear after un-named arguments for Python to accept the method call

- *Resume the run*::

    g.resume()

- *Set the value of "MY_BLOCK" to 20 and confirm (using ``genie_python``) that the instrument has entered a waiting state*::

    # Can use either way of specifying cset for a single block
    g.cset(MY_BLOCK=20)

    # Can verify in any sensible way, so long as we're getting g.runstate()
    if g.runstate()=="WAITING":
        print "The instrument is waiting"
    else:
        print "The instrument is not waiting"

- *Decrease the value of "MY_BLOCK" down in steps of 1 until it reaches 5. Wait for 1 second between steps. Notice how the run state changes back to running when the block value drops below 10*::

    for i in range(g.cget("MY_BLOCK")['value'], 4, -1):
        g.cset(MY_BLOCK=i)
        g.waitfor(seconds=1)
        
- *End the run*::

     g.end()